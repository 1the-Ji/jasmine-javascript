# 비동기와 성능

## 1. 비동기성: 지금과 나중

### 1.1. 프로그램 덩이
- 자바스크립트는 여러개의 '덩이'로 구성
- '지금 실행중인 덩이' + '나중에 실행중인 덩이'
- 가장 일반적인 덩이 단위 -> 함수<br>
> '나중'은 지금의 직후가 아니다. 지금 당장 끝낼 수 없는 작업들은 비동기적으로 처리

```javascript
function now(){
  return 21;
}
function later(){
  answer = answer * 2;            // 나중
  console.log("인생의 의미",answer); // 나중
}

var answer = now();

setTimeout(later,1000); //인생의 의미 : 42

```

#### 1.1.1 비동기 콘솔
> Console.* 메소드는 호스팅 환경에 추가된 기능이다. (공식적으로 자바스크립트 일부분이 아님)
 <br> > 브라우저와 자바스크립트 실행환경에 따라 작동 방식이 다르고 종종 혼돈을 유발

ex) console.log 
``` javascript
var  a = {
  index : 1;
}

console.log(index);
a.index++;
```

### 1.2 이벤트 루프
실제로 비동기 자바스크립트 코드를 쭉 작성해왔다고 해도, 실제로 자바스크립트에 비동기였던적은 한번도 없음!
<br> > 자바스크립트 엔진은 요청하면 프로그램을 주어진 시점에 한덩이씩 묵묵히 실행해주는 역할임
- 자바스크립트 엔진은 반드시 호스팅에서 실행이 된다
- 자바스크립트 엔진은 시간이라는 관념따위는 없고, 임의의 자바스크립트 조각을 주는대로 받아 처리하는 실행기일 뿐, '이벤트(자바스크립트 코드 실행)'를 스케줄링 하는 일은 언제나 <b>주휘 환경의 목<b> 이다.

ex) Ajax, setTimeout
응답에 대한 콜백함수를 이벤트 루프에 삽입

```javascript

var eventLoop = [];
var event;

while(true){
  //틱 발생
  if(eventLoop.length){
    event = event.shift();
    //이제 다음이벤트를 실행
    try{
      event();
    }catch(err){
        reportError();
    }
  }
}
```
> 틱 : 루프의 매순회 , 틱이 발생할 때 마다 큐에 적재된 이벤트(콜백함수)를 꺼내어 실행한다.

자바스크립트 프로그램은 수 많은 덩이로 잘개 나누어지고, 이벤트 루프 큐에서 한 번에 하나씩 차례대로 실행, 큐에 개발자가 작성한 코드 또는 여타 이벤트들도 중간에 끼어들 가능성이 있음

### 1.3 병령 스레딩

'비동기'와 '병렬'은 아무렇게나 섞어 쓰는 경우가 많지만 그 의미는 다름
- 비동기 > 지금과 나중사이의 간극에 관현 용어
- 병렬 > 동시에 일어나는 일들과 연관

'프로세스'와 '스레드'는 가장 많이 쓰는 병렬 컴퓨팅 도구로, 별개의 프로세서 , 심지어는 물리적으로 분리된 컴퓨터에서도 독립적으로 실행되며 여러 스레드는 하나의 프로세스 메모리를 공유한다.
> 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유메모리에 병렬로 접근하거나 변경 할 수 없다. '병렬성'과 '직렬성'이 나뉜 이벤트 루프를 협동하는 형태로 공존

```javascript
  var a = 20;
  function foo(){
    a = a + 1;
  }
  function bar(){
    a = a * 2;
  }
  ajax("~~~",foo);
  ajax("~~~",bar);
```
자바스크립트는 절대로 스레드간의 데이터를 데이터를 공유하는 법이 없으므로 비 결정성의 수준은 문제가 되지 않지만, 그렇다고 자바스크립트가 항성 결정적이라는건 아님 ..> 먼 개소리지..ㄸ

#### 1.3.1. 완전-실행
 > 완전-실행 : 호출한 함수 전체가 실행이 되고 나서야 다른 함수가 실행

 자바스크립트의 작동모드는 단일-스레드
 ```javascript
var a = 1;
var b = 2;

function foo(){
  a++;
  b = b * a;
  a = a + 3;
}

function bar(){
  b--;
  a = 8 + b;
  b = a * 2;
}

ajax("~~~~~~",foo);
ajax("~~~~~~",bar);
 ```
 - 똑같은 코드이지만 결과값은 두가지 이므로 비결정적이다. 스레드 보다 결정적이다.
  <br> > 비결정성은 함수의 순서에 따른 것이지, 스레드 처럼 문의 순서 수준까지는 아님

### 1.4. 동시성

> 복수의 "프로세스"가 같은 시간 동안 동시에 실행됨을 의미, 각 프로세스들이 병렬로 처리되는 지와 관계가 없음 -> 프로세스 수준의 병행성이라고 할수 있음

#### 1.4.1. 비상호 작용
> 복수의 "프로세스" 단계/이벤트를 동시에 인터리빙 할때 이들 프로세스 사이에 연관된 작업이 없다면 프로세스 간 상호 작용은 사실 의미 없음 > 프로세스 간 상호작용 일어나지 않으면 비결정성은 완벽하게 수용 가능
```javascript

var res = {};

function foo(results){
  res.foo = results;
}

function bar(results){
  res.bar = results;
}
ajax("~~~~",foo);
ajax("~~~~",bar);
```
#### 1.4.2. 상호 작용
> 동시 "프로세스"등릉 필요할 떄 스코프나 DOM을 통해 간접적으로 상호 작용을 한다. 이때 이미 한번 살펴봤던 것처럼 경합 조건이 발생하지 않도록 잘 조율해주어야함

#### 1.4.3. 협동
> "협동적 동시성"은 동시성을 조정하는 다른 방안으로, 스코프에서 값을 공유하는 식의 상효 작용보다는 실행 시간이 오래 걸리는 "프로세스"를 여러 단계/배치로 쪼개어 다른 동시 "프로세스"가 각자 작업을 이벤트루프 큐에 인터리빙 하도록 하는게 목표다.

### 1.5. 잡
> 잡 큐는 이벤트 루프 큐에서 '매 틱의 끝자락에 매달려있는 큐'라고 생각하면 됨

- 이벤트 로프 틱 도중 발생 가능한, 비동기 특성이 내재된 액션으로 인해 전혀 새로운 이벤트가 이벤트 루프 큐에 추가되는 게 아니라 현재 틱의 잡 큐 끝 부분에 원소(잡)가 추가된다.
- 개념적으로는 프로그램에서 실행 시간이 긴 코드 또는 무한 루프 (while(true)) 를 표헌 한 것과 비슷하다.
- 잡은 기본적으로 setTimeout() 같은 꼼수와 의도는 비슷하지만 처리 순서가 더 잘 정의되어 있고 순서가 확실히 보장되는 방향으로 구현되어 있다.


### 1.6. 문 순서
자바스크립트 엔진은 반드시 프로그램에 표현된 문의 순서대로 실행 하지 않는다,
단, 컴파일 과정에서 최적화를 하려고 소스를 바꿔서 실행함


## 2. 콜백
어떤 경우든 함수는 "콜백" 역할을 하고, 쿠에서 대기 중인 코드가 처리되자마자 본 프로그램으로 '되돌아올'목적지기 때문이다.

### 2.1. 연속성
```javascript
  //A
  ajax("~~~~",function(){
    //C
  });
  //B
```
> 콜백 함수는 프로그램의 연속성을 감싼 캡슐화 장치이다.
### 2.2. 두뇌는 순차적이다

#### 2.2.1. 실행 vs 계획
우리 두뇌는 멀티태스킹이 아니라 매우 빠른 콘텍스트 교환이다.

#### 2.2.2. 중첩/연쇄된 콜백
```javascript
doA(function(){
  doB();
  doC(function(){
    doD();
  });

  doE();
});

doF();
```
- 하드코딩 문제? > 하드코딩은 기본적으로 부실한 코드를 양산하기에 단계까 나아가는 도중 엉뚱한 일들이 발생하여 오류가 나는것 까지 대비를 할수 없음
### 2.3. 믿음성 문제
- 제어권 교환(개발자가 직접제어가 아닌 서드파티가 제공한 유틸리티)
- 제어의 역전(서드파티에 의존해야하는 상황)

#### 2.3.1 다섯 마리 콜백 이야기

#### 2.3.2 남의 코드 뿐만 아니라

### 2.4. 콜백을 구하라
- 에러 우선 스타일 (콜백 패턴)

# 과제 1. foo()의 호출부를 바꿔서 함수 호출 순서를 바꿔라 2가지 해보기 (단, foo()와 bar()의 호출은 바꾸면안됨)
```javascript
var a = 20;
function foo(){
  //A
    a = a + 1;
    console.log("foo " + a);
}
function bar(){
   a = a * 2;
   console.log("bar " + a);
}
foo();
bar();
```